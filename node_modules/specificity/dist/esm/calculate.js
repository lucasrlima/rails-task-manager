var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { parse, toPlainObject, } from "css-tree";
import { compareDesc } from "./sort.js";
var universalSelectorName = "*";
var increment = function (node, _a, level) {
    var _b;
    var _c, _d, _e, _f, _g, _h, _j, _k;
    var total = _a.total, contributingParts = _a.contributingParts;
    return ({
        total: __assign(__assign({}, total), (_b = {}, _b[level] = total[level] + 1, _b)),
        contributingParts: __spreadArray(__spreadArray([], contributingParts, true), [
            {
                level: level,
                start: {
                    line: (_d = (_c = node === null || node === void 0 ? void 0 : node.loc) === null || _c === void 0 ? void 0 : _c.start.line) !== null && _d !== void 0 ? _d : 1,
                    column: (_f = (_e = node === null || node === void 0 ? void 0 : node.loc) === null || _e === void 0 ? void 0 : _e.start.column) !== null && _f !== void 0 ? _f : 1,
                },
                end: {
                    line: (_h = (_g = node === null || node === void 0 ? void 0 : node.loc) === null || _g === void 0 ? void 0 : _g.end.line) !== null && _h !== void 0 ? _h : 1,
                    column: (_k = (_j = node === null || node === void 0 ? void 0 : node.loc) === null || _j === void 0 ? void 0 : _j.end.column) !== null && _k !== void 0 ? _k : 1,
                },
            },
        ], false),
    });
};
var psuedoElementsWithDeprecatedOneColonNotation = [
    "before",
    "after",
    "first-line",
    "first-letter",
];
var getChildrenFromPseudoClassNode = function (node) {
    if (node.children) {
        var firstChild = node.children[0];
        if (firstChild.type === "SelectorList") {
            return firstChild.children;
        }
        else if (firstChild.type === "Nth" && firstChild.selector) {
            return firstChild.selector.children;
        }
        else {
            return node.children;
        }
    }
    return [];
};
var handlePseudoClassSelector = function (node, accumulatingResult) {
    var name = node.name.toLowerCase();
    var children = getChildrenFromPseudoClassNode(node);
    if (name === "not" || name === "is" || name === "has") {
        // The specificity of an :is(), :not(), or :has() pseudo-class is replaced by the specificity of the most specific complex selector in its selector list argument
        if (children.length > 0) {
            return children
                .map(function (childNode) { return traverse(childNode, accumulatingResult); })
                .sort(function (a, b) { return compareDesc(a.total, b.total); })[0];
        }
    }
    else if (name === "nth-child" || name === "nth-last-child") {
        // The specificity of an :nth-child() or :nth-last-child() selector is the specificity of the pseudo class itself (counting as one pseudo-class selector) plus the specificity of the most specific complex selector in its selector list argument (if any).
        if (children.length > 0) {
            var highestChildSpecificity = children
                .map(function (childNode) { return traverse(childNode, increment(node, accumulatingResult, "B")); })
                .sort(function (a, b) { return compareDesc(a.total, b.total); })[0];
            return highestChildSpecificity;
        }
        else {
            return increment(node, accumulatingResult, "B");
        }
    }
    else if (name === "where") {
        // The specificity of a :where() pseudo-class is replaced by zero.
        return accumulatingResult;
    }
    else if (name === "global" || name === "local") {
        // The specificity for :global() and :local() is replaced by the specificity of the child selector because although they look like psuedo classes they are actually an identifier for CSS Modules
        if (children.length > 0) {
            return children.reduce(function (acc, childNode) { return traverse(childNode, acc); }, accumulatingResult);
        }
    }
    else if (psuedoElementsWithDeprecatedOneColonNotation.includes(name)) {
        // These pseudo-elements can look like pseudo-classes
        // https://www.w3.org/TR/selectors-4/#pseudo-elements
        return increment(node, accumulatingResult, "C");
    }
    else {
        return increment(node, accumulatingResult, "B");
    }
    return accumulatingResult;
};
var traverse = function (node, accumulatingResult) {
    var _a, _b, _c, _d;
    if (accumulatingResult === void 0) { accumulatingResult = {
        total: { A: 0, B: 0, C: 0 },
        contributingParts: [],
    }; }
    if (node.type === "IdSelector") {
        return increment(node, accumulatingResult, "A");
    }
    else if (node.type === "PseudoClassSelector") {
        return handlePseudoClassSelector(node, accumulatingResult);
    }
    else if (node.type === "ClassSelector" ||
        node.type === "AttributeSelector") {
        return increment(node, accumulatingResult, "B");
    }
    else if (node.type === "TypeSelector") {
        if (node.name !== universalSelectorName) {
            return increment(node, accumulatingResult, "C");
        }
    }
    else if (node.type === "PseudoElementSelector") {
        return increment(node, accumulatingResult, "C");
    }
    else if (node.type === "Selector" || node.type === "SelectorList") {
        return node.children.reduce(function (acc, childNode) { return traverse(childNode, acc); }, accumulatingResult);
    }
    else if (node.type === "Raw") {
        return traverse(toPlainObject(parse(node.value, {
            context: "selector",
            positions: true,
            line: (_b = (_a = node === null || node === void 0 ? void 0 : node.loc) === null || _a === void 0 ? void 0 : _a.end.line) !== null && _b !== void 0 ? _b : 1,
            column: (_d = (_c = node === null || node === void 0 ? void 0 : node.loc) === null || _c === void 0 ? void 0 : _c.end.column) !== null && _d !== void 0 ? _d : 1,
        })), accumulatingResult);
    }
    return accumulatingResult;
};
export var calculate = function (selector) {
    var ast = toPlainObject(parse(selector, {
        context: "selector",
    }));
    return traverse(ast).total;
};
export var calculateWithDetails = function (selector) {
    var ast = toPlainObject(parse(selector, {
        context: "selector",
        positions: true,
    }));
    return traverse(ast);
};
//# sourceMappingURL=calculate.js.map